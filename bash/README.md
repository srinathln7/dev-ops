# `"$@"` vs `"$*"`
The `"$@"` symbol in a shell script is a special variable that represents all the positional parameters (arguments) passed to the script or function. It preserves the integrity of each argument, including spaces and special characters, by treating each argument as a separate quoted string.

## Detailed Explanation

- **`"$@"`**: Expands to all the positional parameters, starting from `$1`, `$2`, and so on. Each parameter is quoted separately, which means each argument is treated as a distinct word, preserving spaces and special characters within each argument.

### Examples

1. **Using `"$@"` in a Script**

   Suppose you have a script named `example.sh`:

   ```sh
   #!/bin/bash
   echo "Arguments received:"
   for arg in "$@"; then
     echo "$arg"
   done
   ```

   If you run the script with multiple arguments:

   ```sh
   ./example.sh "first arg" second "third arg with spaces"
   ```

   The output will be:

   ```
   Arguments received:
   first arg
   second
   third arg with spaces
   ```

   Each argument is preserved as passed, including spaces within quotes.

2. **Difference Between `"$@"` and `$*`**

   - `"$@"` treats each quoted argument as a separate entity.
   - `$*` combines all arguments into a single string, separated by the first character of the `IFS` (Internal Field Separator) variable (usually a space).

   Let's modify the script to demonstrate the difference:

   ```sh
   #!/bin/bash
   echo "Using \$@:"
   for arg in "$@"; then
     echo "$arg"
   done

   echo "Using \$*:"
   for arg in $*; then
     echo "$arg"
   done
   ```

   Running the script with the same arguments:

   ```sh
   ./example.sh "first arg" second "third arg with spaces"
   ```

   The output will be:

   ```
   Using $@:
   first arg
   second
   third arg with spaces
   Using $*:
   first
   arg
   second
   third
   arg
   with
   spaces
   ```

   Here, `$*` splits arguments on spaces, leading to unexpected behavior compared to `"$@"`.

## Summary

- `"$@"` is used to handle all positional parameters while preserving each parameter as a distinct word.
- It is particularly useful in loops and when passing arguments to functions or other commands within a script.
- `"$@"` ensures that arguments with spaces or special characters are properly handled as individual entities, avoiding potential issues with argument splitting.



## Java Version

`java -version` gives you the complete version output.

`2>&1 > /dev/null` addition does following things: with 2>&1 the error output of the java -version command will be discarded by the /dev/null file, and > redirects the output of java -version command to the /dev/null file, which is a special type of file, that accepts and discards all input written to it. So described together, this option takes the output, including any errors generated by the java -version command and discards it, not showing it on the command-line and silently forwarding it using | (pipe) to the next command, which is grep "java version\|openjdk version".
Every time, we execute a program or a command, operating system opens three files: standard input, standard output, and standard error, and each file gets a file descriptor integer from the OS: 0, 1, and 2, respectively. So 2>&1 simply says redirect standard error (2) to standard output (1). The & before 1 in this case, means whatever follows is a file descriptor, not a filename.

`grep "java version\|openjdk version"` simply finds a line in the output that has "java version" or "openjdk version" in it. The example line will look like this: openjdk version "11.0.16" 2022-07-19

`awk '{print substr($3,2,2)}` takes the line from the previous output and grabs the third section of the string "11.0.16" and from there grabs the first 2 characters, which will be "11"



